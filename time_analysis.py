# -*- coding: utf-8 -*-
"""NPJ_Submission_Time.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xyIa1_tx77mk4EXYHFzwciq9IfJX7cJ_

## **Installing and loading the relevant libraries**
"""

#Install the libraries
!pip install pandas
!pip install --upgrade openai
!pip install numpy
!pip install transformers
!pip install spacy
!pip install statsmodels
!pip install pingouin
!python -m spacy download en_core_web_sm

import pandas as pd
import pingouin as pg
import openai
import matplotlib.pyplot as plt
import spacy
from transformers import pipeline
import nltk
import numpy as np
import scipy.stats as stats

nltk.download('punkt')
from nltk.tokenize import word_tokenize, sent_tokenize

"""## **Time Analysis**

Clinician Time Analysis
"""

# Create a mapping for the categories to midpoints
time_mapping = {
    '1 min or less': 0.5,
    '1 min - 3 mins': 2,
    '3 mins - 5 mins': 4,
    '5 mins - 7 mins': 6,
    '7 mins - 10 mins': 8.5,
    '10 mins - 13 mins': 11.5,
    '13 mins - 15 mins': 14,
    '15 mins - 20 mins': 17.5,
    'more than 20 mins': 25  # Suitable value for 'more than 20 mins'
}

# Map the 'Dr. 1 Time to Answer' and 'Dr. 2 Time to Answer' columns to midpoints
MDTime['Dr. 1 Time to Answer (Midpoint)'] = MDTime['Dr. 1 Time to Answer'].map(time_mapping)
MDTime['Dr. 2 Time to Answer (Midpoint)'] = MDTime['Dr. 2 Time to Answer'].map(time_mapping)
MDTime['Nurses Time to Answer (Midpoint)'] = MDTime['Nurses Time to Answer'].map(time_mapping)


# Calculate the average time for each column
average_time_dr_1 = MDTime['Dr. 1 Time to Answer (Midpoint)'].mean()
average_time_dr_2 = MDTime['Dr. 2 Time to Answer (Midpoint)'].mean()
average_time_nurses = MDTime['Nurses Time to Answer (Midpoint)'].mean()


# Display the average times
print(f"The average time for Dr. 1 is: {average_time_dr_1} mins")
print(f"The average time for Dr. 2 is: {average_time_dr_2} mins")
print(f"The average time for Nurses is: {average_time_nurses} mins")

# Mapping categories
category_mapping = {
    'Will use this without editing': 0,
    'Minor (<1 minute) editing': 1,
    'Major editing': 2,
    'Would not use this': 3
}

# Map the 'Extensive Editing Required' columns for both graders
MDGrade['Dr.1Extensive editing required (Mapped)'] = MDGrade['Dr.1Extensive editing required'].map(category_mapping)
MDGrade['Dr.2Extensive editing required (Mapped)'] = MDGrade['Dr.2Extensive editing required'].map(category_mapping)

# Calculate the average of the two graders
MDGrade['Average Extensive Editing Required'] = MDGrade[['Dr.1Extensive editing required (Mapped)', 'Dr.2Extensive editing required (Mapped)']].mean(axis=1)

# Calculate descriptive statistics for both graders and the average
dr_h_stats = MDGrade['Dr.1Extensive editing required (Mapped)'].describe()
other_grader_stats = MDGrade['Dr.2Extensive editing required (Mapped)'].describe()
average_stats = MDGrade['Average Extensive Editing Required'].describe()

# Create a summary DataFrame with all the statistics
stats_df = pd.DataFrame({
    'Dr. 1 Extensive Editing Stats': dr_1_stats,
    'Dr.2 Extensive Editing Stats': dr_2_stats,
    'Average Extensive Editing Stats': average_stats
})

# Display the statistics
print("Statistics for 'Dr. 1 Extensive Editing Required':")
print(dr_h_stats)
print("\nStatistics for 'Dr. 2 Extensive Editing Required':")
print(other_grader_stats)
print("\nStatistics for 'Average Extensive Editing Required':")
print(average_stats)

"""Nurse Time Analysis"""

# Count total 'Yes' and 'No' in the full dataset
full_value_counts = NurseTime['I can answer this Inquiry.1'].value_counts()

# Count missing values in 'Nurses Time to Answer (Midpoint)' for "Yes" and "No"
missing_yes_inquiry = NurseTime[(NurseTime['I can answer this Inquiry.1'] == 'Yes') & (NurseTime['Nurses Time to Answer (Midpoint)'].isnull())].shape[0]
missing_no_inquiry = NurseTime[(NurseTime['I can answer this Inquiry.1'] == 'No') & (NurseTime['Nurses Time to Answer (Midpoint)'].isnull())].shape[0]

# Display results
full_value_counts, missing_yes_inquiry, missing_no_inquiry

# Calculate statistics for 'Nurses Time to Answer (Midpoint)' when 'I can answer this Inquiry.1' is 'Yes'
yes_stats_corrected = yes_inquiry['Nurses Time to Answer (Midpoint)'].describe()

# Calculate statistics for 'Nurses Time to Answer (Midpoint)' when 'I can answer this Inquiry.1' is 'No'
no_stats_corrected = no_inquiry['Nurses Time to Answer (Midpoint)'].describe()

# Display the statistics for both "Yes" and "No"
yes_stats_corrected, no_stats_corrected

# Filter data where 'I can answer this Inquiry' is "Yes" and "No"
yes_data = MDTime[MDTime['I can answer this Inquiry'] == 'Yes']['Nurses Time to Answer (Midpoint)']
no_data = MDTime[MDTime['I can answer this Inquiry'] == 'No']['Nurses Time to Answer (Midpoint)']

# Calculate statistics for "Yes" data
yes_stats = yes_data.describe()

# Calculate statistics for "No" data
no_stats = no_data.describe()

# Print the statistics
print("Statistics for 'I can answer this Inquiry' = Yes:")
print(yes_stats)
print("\nStatistics for 'I can answer this Inquiry' = No:")
print(no_stats)

"""Visualizations of Comparison Results of Clinician and Nurse Graders"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Calculate the average time between Dr. H and Dr. B
MDTime['Dr Average'] = MDTime[['Dr. H Time to Answer (Midpoint)', 'Dr. B Time to Answer (Midpoint)']].mean(axis=1)

# Define the time bins and corresponding labels
bins = [0, 1, 3, 5, 7, 9]  # Example bins for time ranges
labels = ['0.5', '2.0', '4.0', '6.0', '8.5']  # Labels representing midpoints of the ranges

# Add a new column to categorize the 'Dr Average' and 'Nurses Time to Answer'
MDTime['Dr Average Binned'] = pd.cut(MDTime['Dr Average'], bins=bins, labels=labels, include_lowest=True)
MDTime['Nurse Time Binned'] = pd.cut(MDTime['Nurses Time to Answer (Midpoint)'], bins=bins, labels=labels, include_lowest=True)

# Filter out NaN values for the required columns
mdtime_filtered = MDTime.dropna(subset=['Dr Average Binned', 'Nurse Time Binned'])

# Create the counts for each time category for Dr. Average and Nurse
dr_avg_counts = mdtime_filtered['Dr Average Binned'].value_counts(sort=False)
nurse_counts = mdtime_filtered['Nurse Time Binned'].value_counts(sort=False)

# Define the width of the bars and the positions on the x-axis
bar_width = 0.35
index = np.arange(len(labels))

# Plotting the bars side by side
plt.figure(figsize=(12, 8))
bar1 = plt.bar(index, dr_avg_counts, bar_width, color='lightblue', label='Dr Average')
bar2 = plt.bar(index + bar_width, nurse_counts, bar_width, color='lightcoral', label='Nurse')

# Add labels, title, and grid
plt.xlabel('Time to Answer (Minutes)', fontsize=18)
plt.ylabel('Frequency', fontsize=18)
# plt.title('Comparison of Time to Answer - Averege of Two Clinician Graders vs Nurse', fontsize=18, fontweight='bold')
plt.xticks(index + bar_width / 2, labels, fontsize=18)
plt.yticks(fontsize=18)
plt.grid(axis='y', linestyle='--', alpha=0.7)

# Adding a legend
plt.legend(fontsize=12)

# Adding data labels on top of bars
for bar in bar1:
    yval = bar.get_height()
    plt.text(bar.get_x() + bar.get_width()/2, yval + 1, int(yval), ha='center', fontsize=16, color='black')

for bar in bar2:
    yval = bar.get_height()
    plt.text(bar.get_x() + bar.get_width()/2, yval + 1, int(yval), ha='center', fontsize=16, color='black')

# Show plot with a tighter layout
plt.tight_layout()
plt.show()

"""Estimate the Reading Time"""

# Function to count words
def count_words(text):
    if pd.isna(text):  # Handle missing/NaN values
        return 0
    return len(str(text).split())

# Apply word count to the 'MessageNote' and 'Response' columns
ReadingTime['MessageNote_WordCount'] = ReadingTime['MessageNote'].apply(count_words)
ReadingTime['Response_WordCount'] = ReadingTime['Response.1'].apply(count_words)

# Show the result
ReadingTime[['MessageNote', 'MessageNote_WordCount', 'Response', 'Response_WordCount']]

# Average reading speed (words per minute)
WPM = 175

# Function to calculate reading time
def calculate_reading_time(word_count, wpm=WPM):
    return word_count / wpm

# Calculate reading time for 'MessageNote' and 'Response' columns
ReadingTime['MessageNote_ReadingTime'] = ReadingTime['MessageNote_WordCount'].apply(lambda x: calculate_reading_time(x, WPM))
ReadingTime['Response_ReadingTime'] = ReadingTime['Response_WordCount'].apply(lambda x: calculate_reading_time(x, WPM))

# Show the result
ReadingTime[['MessageNote', 'MessageNote_WordCount', 'MessageNote_ReadingTime', 'Response', 'Response_WordCount', 'Response_ReadingTime']]

ReadingTime.to_excel('updated_data_with_reading_time.xlsx', index=False)
files.download('updated_data_with_reading_time.xlsx')  # Download the updated file

"""Calculate Human Care Team Responses Wait Time"""

# Convert 'CreatedTime' and 'Clinician Time' to datetime, forcing errors to NaT (Not a Time) if conversion fails
Wait_Time['CreatedTime'] = pd.to_datetime(Wait_Time['CreatedTime'], errors='coerce')
Wait_Time['Clinician Time'] = pd.to_datetime(Wait_Time['Clinician Time'], errors='coerce')

# Print the dtypes to verify conversion
print(Wait_Time.dtypes)

# Check for any NaT values (failed conversions)
print(Wait_Time[Wait_Time['CreatedTime'].isna() | Wait_Time['Clinician Time'].isna()])

# Calculate the difference in minutes if no conversion errors
if not Wait_Time['CreatedTime'].isna().any() and not Wait_Time['Clinician Time'].isna().any():
    Wait_Time['Difference_Minutes'] = (Wait_Time['Clinician Time'] - Wait_Time['CreatedTime']).dt.total_seconds() / 60

    # Display the result
    print(Wait_Time[['CreatedTime', 'Clinician Time', 'Difference_Minutes']])

    # If needed, sum the total minutes
    total_minutes = Wait_Time['Difference_Minutes'].sum()
    print(f"Total Minutes: {total_minutes}")
else:
    print("There are rows with invalid datetime formats. Please check the data.")

# Calculate the average difference in minutes
average_difference_minutes = Wait_Time['Difference_Minutes'].mean()
print(f"Average Difference in Minutes: {average_difference_minutes:.2f}")

# Calculate the difference in hours
Wait_Time['Difference_Hours'] = Wait_Time['Difference_Minutes'] / 60

# Display the result
print(Wait_Time[['CreatedTime', 'Clinician Time', 'Difference_Hours']])

# Generate basic statistics for Difference_Hours
mean_hours = Wait_Time['Difference_Hours'].mean()
median_hours = Wait_Time['Difference_Hours'].median()
std_dev_hours = Wait_Time['Difference_Hours'].std()
min_hours = Wait_Time['Difference_Hours'].min()
max_hours = Wait_Time['Difference_Hours'].max()

# Print the statistics
print(f"Mean Difference in Hours: {mean_hours:.2f}")
print(f"Median Difference in Hours: {median_hours:.2f}")
print(f"Standard Deviation of Difference in Hours: {std_dev_hours:.2f}")
print(f"Minimum Difference in Hours: {min_hours:.2f}")
print(f"Maximum Difference in Hours: {max_hours:.2f}")

# Categorize the Difference_Hours into bins
bins = [0, 24, 48, 72, float('inf')]
labels = ['0-24 hrs', '24-48 hrs', '48-72 hrs', '> 72 hrs']
Wait_Time['Time_Category'] = pd.cut(Wait_Time['Difference_Hours'], bins=bins, labels=labels, right=False)

# Count the number of entries in each bin
category_counts = Wait_Time['Time_Category'].value_counts().sort_index()

# Generate a bar plot for the categorized data
fig, ax = plt.subplots(figsize=(10, 6))

# Use the custom color for all bars
bars = ax.bar(category_counts.index, category_counts.values, color='#f5a525', edgecolor='black')

# Add data labels on top of each bar with better formatting
for bar in bars:
    yval = bar.get_height()
    ax.text(bar.get_x() + bar.get_width()/2, yval + 0.5, int(yval), ha='center', va='bottom', fontsize=14, color='black')

# Add gridlines for better readability
ax.yaxis.grid(True, linestyle='--', which='major', color='grey', alpha=0.7)

# Remove the top and right spines for a cleaner look
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
plt.rcParams['figure.dpi'] = 180
# Set titles and labels with enhanced styling
plt.title('Distribution of Time Differences by Category', fontsize=20)
plt.xlabel('Wait Time Categories', fontsize=18)
plt.ylabel('Patient Inquiries', fontsize=18)

# Show the plot with a tight layout
plt.tight_layout()
plt.show()